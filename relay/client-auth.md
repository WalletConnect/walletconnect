# Relay Client Auth

## Motivation

WalletConnect supports e2e encrypted messaging between multiple clients.
Should a recipient be offline, WalletConnect stores the encrypted messages in the recipient's mailbox until they reconnect.
The address of the mailbox is a unique sticky _client_id_ that clients present when they connect to WalletConnect.

This document discusses the creation and usage of the _client_id_ for authentication

## Overview

WalletConnect expects an `Authentication Bearer <signed jwt>` header when establishing the Websocket connection. Where websocket headers are not supported i.e browsers, use url query param `?auth=<signed jwt>`. Server should support both of these mechanisms.
WalletConnect exposes a `HTTP GET /auth-nonce?did=<client_id>` endpoint to retrieve a nonce.

The `client_id` is a did of the public key for the key pair generated by the client when instantiating the SDK and persisted for the entire lifecyle.

The Bearer is a standard signed JWT token which contains the authentication nonce as subject and did as the issuer.

## Specification

Here we describe how a client can generate a Ed25519 key pair to authenticate itself using the public key as it's client id

Additionally we describe how we can construct and sign a JWT using the authentication nonce for relay server authentication

Finally we describe how the public key is encoded as `did:key` identifier which is used as client id.

### API

```typescript
// ---------- API ----------------------------------------------- //

function signJWT(subject: string, keyPair: ed25519.KeyPair): Promise<string>;
function verifyJWT(jwt: string): Promise<boolean>;

// ---------- Utilities ----------------------------------------------- //

function decodeJSON(str: string): any;
function encodeJSON(val: any): string;

function encodeIss(publicKey: Uint8Array): string;
function decodeIss(issuer: string): Uint8Array;

function encodeSig(bytes: Uint8Array): string;
function decodeSig(encoded: string): Uint8Array;

function encodeData(params: IridiumJWTData): string;
function decodeData(jwt: string): IridiumJWTData;

function encodeJWT(params: IridiumJWTSigned): string;
function decodeJWT(jwt: string): IridiumJWTSigned;
```

### Reference Implementation

```typescript
import * as ed25519 from "@stablelib/ed25519";
import { concat } from "uint8arrays/concat";
import { toString } from "uint8arrays/to-string";
import { fromString } from "uint8arrays/from-string";
import { safeJsonParse, safeJsonStringify } from "@walletconnect/safe-json";

// ---------- Interfaces ----------------------------------------------- //

interface IridiumJWTHeader {
  alg: "EdDSA";
  typ: "JWT";
}

interface IridiumJWTPayload {
  iss: string;
  sub: string;
}

interface IridiumJWTData {
  header: IridiumJWTHeader;
  payload: IridiumJWTPayload;
}

interface IridiumJWTSigned extends IridiumJWTData {
  signature: Uint8Array;
}

// ---------- Constants ----------------------------------------------- //

const JWT_IRIDIUM_ALG: IridiumJWTHeader["alg"] = "EdDSA";

const JWT_IRIDIUM_TYP: IridiumJWTHeader["typ"] = "JWT";

const JWT_DELIMITER = ".";

const JWT_ENCODING = "base64url";

const JSON_ENCODING = "utf8";

const DID_DELIMITER = ":";

const DID_PREFIX = "did";

const DID_METHOD = "key";

const MULTICODEC_ED25519_ENCODING = "base58btc";

const MULTICODEC_ED25519_BASE = "z";

const MULTICODEC_ED25519_HEADER = "K36";

const MULTICODEC_ED25519_LENGTH = 32;

// ---------- Utilities ----------------------------------------------- //

function decodeJSON(str: string): any {
  return safeJsonParse(toString(fromString(str, JWT_ENCODING), JSON_ENCODING));
}

function encodeJSON(val: any): string {
  return toString(
    fromString(safeJsonStringify(val), JSON_ENCODING),
    JWT_ENCODING
  );
}

function encodeIss(publicKey: Uint8Array): string {
  const header = fromString(
    MULTICODEC_ED25519_HEADER,
    MULTICODEC_ED25519_ENCODING
  );
  const multicodec =
    MULTICODEC_ED25519_BASE +
    toString(concat([header, publicKey]), MULTICODEC_ED25519_ENCODING);
  return [DID_PREFIX, DID_METHOD, multicodec].join(DID_DELIMITER);
}

function decodeIss(issuer: string): Uint8Array {
  const [prefix, method, multicodec] = issuer.split(DID_DELIMITER);
  if (prefix !== DID_PREFIX || method !== DID_METHOD) {
    throw new Error(`Issuer must be a DID with method "key"`);
  }
  const base = multicodec.slice(0, 1);
  if (base !== MULTICODEC_ED25519_BASE) {
    throw new Error(`Issuer must be a key in mulicodec format`);
  }
  const bytes = fromString(multicodec.slice(1), MULTICODEC_ED25519_ENCODING);
  const type = toString(bytes.slice(0, 2), MULTICODEC_ED25519_ENCODING);
  if (type !== MULTICODEC_ED25519_HEADER) {
    throw new Error(`Issuer must be a public key with type "Ed25519"`);
  }
  const publicKey = bytes.slice(2);
  if (publicKey.length !== MULTICODEC_ED25519_LENGTH) {
    throw new Error(`Issuer must be a public key with length 32 bytes`);
  }
  return publicKey;
}

function encodeSig(bytes: Uint8Array): string {
  return toString(bytes, JWT_ENCODING);
}

function decodeSig(encoded: string): Uint8Array {
  return fromString(encoded, JWT_ENCODING);
}

function encodeData(params: IridiumJWTData): string {
  return [encodeJSON(params.header), encodeJSON(params.payload)].join(
    JWT_DELIMITER
  );
}

function decodeData(jwt: string): IridiumJWTData {
  const params = jwt.split(JWT_DELIMITER);
  const header = decodeJSON(params[0]);
  const payload = decodeJSON(params[1]);
  return { header, payload };
}

function encodeJWT(params: IridiumJWTSigned): string {
  return [
    encodeJSON(params.header),
    encodeJSON(params.payload),
    encodeSig(params.signature),
  ].join(JWT_DELIMITER);
}

function decodeJWT(jwt: string): IridiumJWTSigned {
  const params = jwt.split(JWT_DELIMITER);
  const header = decodeJSON(params[0]);
  const payload = decodeJSON(params[1]);
  const signature = decodeSig(params[2]);
  return { header, payload, signature };
}

// ---------- API ----------------------------------------------- //

async function signJWT(subject: string, keyPair: ed25519.KeyPair) {
  const header = { alg: JWT_IRIDIUM_ALG, typ: JWT_IRIDIUM_TYP };
  const issuer = encodeIss(keyPair.publicKey);
  const payload = { iss: issuer, sub: subject };
  const data = fromString(encodeData({ header, payload }), "utf8");
  const signature = ed25519.sign(keyPair.secretKey, data);
  return encodeJWT({ header, payload, signature });
}

async function verifyJWT(jwt: string) {
  const { header, payload, signature } = decodeJWT(jwt);
  if (header.alg !== JWT_IRIDIUM_ALG || header.typ !== JWT_IRIDIUM_TYP) {
    throw new Error("JWT must use EdDSA algorithm");
  }
  const publicKey = decodeIss(payload.iss);
  const data = fromString(encodeData({ header, payload }), "utf8");
  return ed25519.verify(publicKey, data, signature);
}
```

### Test Cases

```JavaScript
// Client will sign the Server assigned socketId as a nonce
const nonce =
  "c479fe5dc464e771e78b193d239a65b58d278cad1c34bfb0b5716e5bb514928e";

// Fixed seed to generate the same key pair
const seed = fromString(
  "58e0254c211b858ef7896b00e3f36beeb13d568d47c6031c4218b87718061295",
  "base16"
);

// Generate key pair from seed
const keyPair = ed25519.generateKeyPairFromSeed(seed);
// secretKey = "58e0254c211b858ef7896b00e3f36beeb13d568d47c6031c4218b87718061295884ab67f787b69e534bfdba8d5beb4e719700e90ac06317ed177d49e5a33be5a"
// publicKey = "884ab67f787b69e534bfdba8d5beb4e719700e90ac06317ed177d49e5a33be5a"

// Expected JWT for given nonce
const expected =
  "eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJkaWQ6a2V5Ono2TWtvZEhad25lVlJTaHRhTGY4SktZa3hwREdwMXZHWm5wR21kQnBYOE0yZXh4SCIsInN1YiI6ImM0NzlmZTVkYzQ2NGU3NzFlNzhiMTkzZDIzOWE2NWI1OGQyNzhjYWQxYzM0YmZiMGI1NzE2ZTViYjUxNDkyOGUifQ.0JkxOM-FV21U7Hk-xycargj_qNRaYV2H5HYtE4GzAeVQYiKWj7YySY5AdSqtCgGzX4Gt98XWXn2kSr9rE1qvCA";

async function test() {
  const jwt = await signJWT(nonce, keyPair);
  console.log("jwt", jwt);
  console.log("matches", jwt === expected);
  const verified = await verifyJWT(jwt);
  console.log("verified", verified);
}

test();
```
